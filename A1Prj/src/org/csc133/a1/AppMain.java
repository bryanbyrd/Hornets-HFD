package org.csc133.a1;


import static com.codename1.ui.CN.*;

import com.codename1.charts.util.ColorUtil;
import com.codename1.ui.*;
import com.codename1.ui.geom.Point;
import com.codename1.ui.layouts.BorderLayout;
import com.codename1.ui.plaf.UIManager;
import com.codename1.ui.util.Resources;
import com.codename1.io.Log;
import java.util.ArrayList;
import java.util.Random;
import com.codename1.ui.util.UITimer;

/**
 * This file was generated by <a href="https://www.codenameone.com/">Codename One</a> for the purpose
 * of building native mobile applications using Java.
 */
public class AppMain {

    private Form current;
    private Resources theme;

    public void init(Object context) {
        // use two network threads instead of one
        updateNetworkThreadCount(2);

        theme = UIManager.initFirstTheme("/theme");

        // Enable Toolbar on all Forms by default
        Toolbar.setGlobalToolbar(true);

        // Pro only feature
        Log.bindCrashProtection(true);

        addNetworkErrorListener(err -> {
            // prevent the event from propagating
            err.consume();
            if (err.getError() != null) {
                Log.e(err.getError());
            }
            Log.sendLogAsync();
            Dialog.show("Connection Error", "There was a networking error in the connection to " + err.getConnectionRequest().getUrl(), "OK", null);
        });
    }

    public void start() {
        if (current != null) {
            current.show();
            return;
        }
        Game g = new Game();
    }

    public void stop() {
        current = getCurrentForm();
        if (current instanceof Dialog) {
            ((Dialog) current).dispose();
            current = getCurrentForm();
        }
    }

    public void destroy() {
    }
}
class Game extends Form implements Runnable {
    private GameWorld gw;

    final static int DISP_W = Display.getInstance().getDisplayWidth();
    final static int DISP_H = Display.getInstance().getDisplayHeight();

    public static int getSmallDim() { return Math.min(DISP_W, DISP_H); }
    public static int getLargeDim() { return Math.max(DISP_W, DISP_H); }

    Game() {
        gw = new GameWorld();

        addKeyListener(-93, (evt) -> gw.rotateLeft());
        addKeyListener(-94, (evt) -> gw.rotateRight());
        addKeyListener(-91, (evt) -> gw.increaseSpeed());
        addKeyListener(-92, (evt) -> gw.decreaseSpeed());
        addKeyListener('f', (evt) -> gw.fightFire());
        addKeyListener('d', (evt) -> gw.drinkWater());
        addKeyListener('Q', (evt) -> gw.quit());


        UITimer timer = new UITimer(this);
        timer.schedule(100, true, this);

        this.getAllStyles().setBgColor(ColorUtil.BLACK);
        this.show();
    }

    public void paint(Graphics g) {
        super.paint(g);
        gw.draw(g);
    }

    @Override
    public void run() {
        gw.tick();
        repaint();
    }
}

class GameWorld {
    private final int FUEL = 20000;
    private River americanRiver;
    private Helipad pad;
    private ArrayList<Fire> fires;
    private Helicopter heli;
    private Boolean play;
    private Dialog endDialog;

    GameWorld() {
        americanRiver = new River();
        fires = new ArrayList<Fire>();
        /*
        For the positioning of the three fire objects, I chose two random
        integers in specific ranges that ensure that each Point allows the
        fires two have a degree of randomness with their locations but
        also ensures that they don't overlap
         */
        Random rand = new Random();
        for (int i = 0; i < 3; i++) {
            if (i == 0) {
                int randomX = rand.nextInt((400 - 100) + 1) + 100;
                int randomY = rand.nextInt((50 - 0) + 1) + 0;
                fires.add(new Fire(randomX,randomY));
            }
            else if (i == 1) {
                int randomX = rand.nextInt((1200 - 800) + 1) + 800;
                int randomY = rand.nextInt((50 - 0) + 1) + 0;
                fires.add(new Fire(randomX,randomY));
            }
            else if (i == 2) {
                int randomX = rand.nextInt((1300 - 400) + 1) + 400;
                int randomY = rand.nextInt((800 - 600) + 1) + 600;
                fires.add(new Fire(randomX,randomY));
            }
        }
        pad = new Helipad();
        heli = new Helicopter(pad.getPoint(), pad.getSize(), FUEL);
        play = true;
        endDialog = new Dialog();
    }

    public void rotateLeft() {
        heli.changeDirection(-15);
    }

    public void rotateRight() {
        heli.changeDirection(15);
    }

    public void increaseSpeed() {
        heli.speedUp();
    }

    public void decreaseSpeed() {
        heli.slowDown();
    }

    public void drinkWater() {
        if (heli.isOverRiver(americanRiver)) {
            heli.getWater();
        }
    }
    /*
    When calling the fight() method, the water value of water will change to 0.
    However, I need to invoke the dumpWater() method if the helicopter isn't
    over a fire to ensure that the water gets dumped regardless
     */
    public void fightFire() {
        for (Fire f: fires) {
            if(heli.isOverFire(f)) {
                heli.fight(f);
            }
        }
        heli.dumpWater();
    }

    /*
    the main primary focus of the init method was to first get rid of the
    dialog on the screen. I then emptied the collection of the initial
    Fire objects and created 3 new ones using the same method in the
    GameWorld constructor. Then all values of the Helicopter object are
    reset
     */
    public void init() {
        endDialog.dispose();
        fires.removeAll(fires);
        Random rand = new Random();
        for (int i = 0; i < 3; i++) {
            if (i == 0) {
                int randomX = rand.nextInt((400 - 100) + 1) + 100;
                int randomY = rand.nextInt((50 - 0) + 1) + 0;
                fires.add(new Fire(randomX,randomY));
            }
            else if (i == 1) {
                int randomX = rand.nextInt((1200 - 800) + 1) + 800;
                int randomY = rand.nextInt((50 - 0) + 1) + 0;
                fires.add(new Fire(randomX,randomY));
            }
            else if (i == 2) {
                int randomX = rand.nextInt((1300 - 400) + 1) + 400;
                int randomY = rand.nextInt((800 - 600) + 1) + 600;
                fires.add(new Fire(randomX,randomY));
            }
        }
        heli.reset(FUEL);
    }

    /*
    For the random growth of the Fire objects, if a random number between
    1 and 150 is selected, I choose one of the 3 Fire objects. If that fire
    is active, then grow() is called on it
     */
    public void tick() {
        heli.move();
        heli.decreaseFuel();
        Random rand = new Random();
        int first = rand.nextInt((200 - 0) + 1) + 0;
        int second = rand.nextInt((3 - 0));
        if (first == 10) {
            if (fires.get(second).isActive()) {
                fires.get(second).grow();
            }
        }
        play = false;
        for (Fire f: fires) {
            if (f.isActive()) {
                play = true;
            }
        }
        /*
        Create dialog for when the player runs out of fuel
         */
        if (heli.getFuel() == 0) {
            endDialog.setLayout(new BorderLayout());
            Label score = new Label("Score: " + heli.getFuel());
            score.getUnselectedStyle().setFgColor(ColorUtil.BLACK);
            Button playAgain = new Button("Play Again");
            Button quitGame = new Button("Quit Game");
            score.getUnselectedStyle().setAlignment(CENTER);
            endDialog.getDialogStyle().setAlignment(CENTER);
            endDialog.setTitle("Game Over!");
            score.setText("You ran out of fuel");
            endDialog.add(NORTH, score);
            playAgain.addActionListener(l -> init());
            quitGame.addActionListener(l -> quit());
            endDialog.add(EAST, playAgain);
            endDialog.add(WEST, quitGame);
            endDialog.show();
        }
        /*
        Create dialog for when player beats the game
         */
        if (heli.isOverHelipad(pad) && play == false) {
            endDialog.setLayout(new BorderLayout());
            Label score = new Label("Score: " + heli.getFuel());
            score.getUnselectedStyle().setFgColor(ColorUtil.BLACK);
            Button playAgain = new Button("Play Again");
            Button quitGame = new Button("Quit Game");
            score.getUnselectedStyle().setAlignment(CENTER);
            endDialog.getDialogStyle().setAlignment(CENTER);
            endDialog.setTitle("You Win!");
            endDialog.add(NORTH, score);
            playAgain.addActionListener(l -> init());
            quitGame.addActionListener(l -> quit());
            endDialog.add(EAST, playAgain);
            endDialog.add(WEST, quitGame);
            endDialog.show();
        }
    }

    public void draw(Graphics g) {
        g.setColor(ColorUtil.BLACK);
        g.fillRect(0, 0, Game.DISP_W, Game.DISP_H);
        americanRiver.draw(g);
        for (Fire f: fires) {
            f.draw(g);
        }
        pad.draw(g);
        heli.draw(g);
    }

    public void quit() {
        Display.getInstance().exitApplication();
    }
}


class River {
    private Point upperBound;
    // Width of the river will always be 1/8th the height of the display
    private int width;
    /*
    The height of the river represents the upper bound of the river and
    will always be positioned 1/4 down the height of the display
     */
    private int height;
    private int length;

    River() {
        height = Game.DISP_H;
        width = height / 8;
        length = Game.DISP_W;
        upperBound = new Point(0, height / 4);
    }

    public Point getUpperBound() {
        return this.upperBound;
    }

    public int getWidth() {
        return width;
    }

    public int getlength() {
        return length;
    }

    public void draw(Graphics g) {
        g.setColor(ColorUtil.BLUE);
        g.drawRect(0, upperBound.getY(), length, width, 10);
    }
}

class Helipad {
    private Point p;
    private int size;

    Helipad() {
        /*
        Point of the Helipad will always be in the exact center of the screen
        with respect to the width of the screen and a specified distance from
        the bottom of the screen
         */
        int xCord = Game.DISP_W / 2;
        int yCord = Game.DISP_H - 150;
        p = new Point(xCord, yCord);
        size = 150;
    }

    public Point getPoint() {
        return p;
    }

    public int getSize() {
        return size;
    }

    public void draw(Graphics g) {
        g.setColor(ColorUtil.GRAY);
        /*
        Since the Helipad's Point is in the center of the screen, offsets are required
        when drawing the helipad to center the square and circle elements with respect
        to this point
         */
        g.drawRect(p.getX() - 75, p.getY() - 75, size, size, 5);
        g.drawRoundRect(
                p.getX() - 55,
                p.getY() - 55,
                110,
                110,
                110,
                110);
    }
}

class Fire {
    private Point p;
    private int size;
    private Boolean active;
    private int increase;

    Fire(int x, int y) {
        p = new Point(x, y);
        Random rand = new Random();
        // Size of the fire will be a random number between 200 and 400
        size = rand.nextInt((400 - 200) + 1) + 250;
        increase = 0;
        active = true;
    }

    public Point getPoint() {
        return p;
    }

    public int getSize() {
        return size;
    }

    public Boolean isActive() { return active; }

    /*
    In order to shrink the fire with respect to its center, every time the size
    is decreased by w, the Point's X and Y values get (w / 2) added to them
     */
    public void shrink(int w) {
        w = w / 3;
        size -= w;
        p.setX(p.getX() + (w / 2));
        p.setY(p.getY() + (w / 2));
        if (size <= 0) {
            active = false;
        }
    }

    /*
    In order to grow the fire with respect to its center, every time the size
    is increased, the Point's X and Y values subtracted by the 1/2 of the
    increased value
    */
    public void grow() {
        Random rand = new Random();
        increase = rand.nextInt((150 - 50) + 1) + 50;
        size += increase;
        p.setX(p.getX() - (increase / 2));
        p.setY(p.getY() - (increase / 2));
    }

    public void draw(Graphics g) {
        if (active) {
            g.setColor(ColorUtil.MAGENTA);
            g.fillRoundRect(p.getX(), p.getY(), size, size, size, size);
            int bottomRightX = size + p.getX();
            int bottomRightY = size + p.getY();
            Font mediumFont = Font.createSystemFont(FACE_SYSTEM, STYLE_BOLD, SIZE_MEDIUM);
            g.setFont(mediumFont);
            g.drawString(Integer.toString(size), bottomRightX, bottomRightY);
        }
    }
}

class Helicopter {
    private final int MAX_SPEED = 10;
    private final int MAX_WATER = 1000;
    private Point p;
    private Point start;
    private int size;
    private int speed;
    private int direction;
    private int waterAmount;
    private int fuel;

    /*
    The helicopter gets the center point of the Helipad passed into its
    constructor along with the size of the helipad and the amount of fuel
    specified by the GameWorld class. p and s are used to ensure that the
    helicopter is centered with respect to the helipad
     */
    Helicopter(Point p, int s, int f) {
        size = (Game.DISP_H * Game.DISP_W) / 80000;
        start = new Point(p.getX() - (size / 2), p.getY() - (size / 2));
        this.p = start;
        speed = 0;
        direction = 0;
        waterAmount = 0;
        fuel = f;
    }

    /*
    The size and point of the Fire object passed into this method are used to
    check whether the X and Y values of the helicopters Point are within the
    bounding rectangle of the fire
     */
    public Boolean isOverFire(Fire f) {
        int fireSize = f.getSize();
        int fireX = f.getPoint().getX();
        int fireY = f.getPoint().getY();
        if (p.getX() >= fireX && p.getX() <= (fireX + fireSize)) {
            if (p.getY() >= fireY && p.getY() <= (fireY + fireSize)) {
                return true;
            }
        }
        return false;
    }

    /*
    The length, width and Point of the river are used in this method to check
    whether the center of the helicopter is within the bounding rectangle of
    the River object
     */
    public Boolean isOverRiver(River r) {
        Point upper = r.getUpperBound();
        int length = r.getlength();
        int width = r.getWidth();
        if (p.getX() >= upper.getX() && p.getX() <= (upper.getX() + length)) {
            if (p.getY() >= upper.getY() && p.getY() <= (upper.getY() + width)) {
                return true;
            }
        }
        return false;
    }

    public Boolean isOverHelipad(Helipad h) {
        int padX = h.getPoint().getX() - 75;
        int padY = h.getPoint().getY() - 75;
        int padSize = h.getSize();
        if (p.getX() >= padX && p.getX() <= (padX + (padSize / 2))) {
            if (p.getY() >= padY && p.getY() <= (padY + (padSize / 2))) {
                if (speed == 0) {
                    return true;
                }
            }
        }
        return false;
    }

    public void speedUp() {
        if (speed < MAX_SPEED) {
            speed++;
        }
    }

    public void slowDown() {
        if (speed > 0) {
            speed--;
        }
    }

    public void changeDirection(int d) {
        direction += d;
    }

    /*
    Adding 270 to the direction element ensures that an initial value of 0 for
    direction represents North on the screen.
     */
    public void move() {
        if (speed != 0) {
            p = new Point(
                    (int) (p.getX() + (Math.cos(Math.toRadians(direction + 270)) * speed)),
                    (int) (p.getY() + (Math.sin(Math.toRadians(direction + 270)) * speed))
            );

        }
    }

    public void decreaseFuel() {
        if (fuel > 0) {
            fuel -= 10;
        }
    }

    public int getFuel() {
        return fuel;
    }

    public void reset(int f) {
        fuel = f;
        speed = 0;
        direction = 0;
        waterAmount = 0;
        p = start;
    }

    public void getWater() {
        if (waterAmount < MAX_WATER && speed <= 2) {
            waterAmount += 100;
        }
    }

    public void dumpWater() {
        waterAmount = 0;
    }

    public void fight(Fire f) {
        f.shrink(waterAmount);
        waterAmount = 0;
    }

    public void draw(Graphics g) {
        g.setColor(ColorUtil.YELLOW);
        Point c = new Point(p.getX() + (size / 2), (p.getY() + (size / 2)));
        double lineX = Math.cos(Math.toRadians(direction + 270));
        double lineY = Math.sin(Math.toRadians(direction + 270));
        lineX = c.getX() + (lineX * 50);
        lineY = c.getY() + (lineY * 50);
        g.fillRoundRect(p.getX(), p.getY(), size, size, size, size);
        g.drawLine(c.getX(), c.getY(), (int) lineX, (int) lineY);
        Font myFont = Font.createSystemFont(FACE_MONOSPACE, STYLE_BOLD, SIZE_MEDIUM);
        g.setFont(myFont);
        g.drawString("F : " + fuel, p.getX(), p.getY() + 100);
        g.drawString("W : " + waterAmount, p.getX(), p.getY() + 130);
    }
}